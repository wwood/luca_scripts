#!/usr/bin/env python2.7

#=======================================================================
# Author(s): Ben Woodcroft
#
# Copyright 2015
#
# This is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License.
# If not, see <http://www.gnu.org/licenses/>.
#=======================================================================

import argparse
import subprocess
import logging
import re
import os, os.path
import shutil

# Add module python interface
execfile("/usr/local/Modules/3.2.10/init/python.py")

class GuixInfo:
    def __init__(self, guix_package_names, guix_exe):
        cmd = "%s package --show=%s" % (guix_exe, guix_package_names[0])
        logging.info("Running cmd: %s" % cmd)
        output = subprocess.check_output(cmd, shell=True)

        if output=='':
            raise Exception("Unfortunately it appears there is no '%s' package in guix" % guix_package_name)

        infos = {}
        r = re.compile("(.+?): (.*)")
        last_key = None
        for l in output.split("\n"):
            if len(l) == 0: continue
            if l[0] == '+':
                if not last_key:
                    raise Exception("info started with a + ?!!?!: %s" % l)
                infos[last_key] += ' '
                infos[last_key]+= l[1:]
            else:
                o = r.search(l)
                if o:
                    last_key = o.groups(0)[0].strip()
                    value = o.groups(0)[1].strip()
                    if last_key in infos:
                        raise Exception("There appears to be multiple packages available, use "
                                        "\"%s package --show=%s\" and guix_module -i %s --guix_package_name @.. with a specific version" % (guix_exe, guix_package_name, guix_package_name))
                    infos[last_key] = value
                else:
                    raise Exception("Badly parsed info line: %s" % l)

        # these throw errors if they don't exist, so don't need to check
        self.name = infos['name']
        self.version = infos['version']
        self.synopsis = infos['synopsis']
        self.description = infos['description']


class SearchPaths:
    def __init__(self, guix_profile_path):
        cmd = "%s package -p '%s' --search-paths" % (guix_exe, guix_profile_path)
        logging.info("Running cmd: %s" % cmd)
        output = subprocess.check_output(cmd, shell=True)

        self.search_paths = {}
        r = re.compile("export (.+?)=(.+)")
        for l in output.split("\n"):
            if len(l) == 0: continue
            o = r.search(l)
            if o:
                last_key = o.groups(0)[0].strip()
                value = o.groups(0)[1].strip()
                self.search_paths[last_key] = value
            else:
                raise Exception("Badly parsed --search-paths line: %s" % l)

class DefaultModuleVersionFile:
    def generate_dotversion(self, modulefiles_directory, new_version):
        dotversion_path = os.path.join(modulefiles_directory, '.version')
        if os.path.exists(dotversion_path):
            shutil.move(dotversion_path,
                      "%s.backup_by_guix_module" % dotversion_path)
        with open(dotversion_path, 'w') as f:
            f.write("#%Module1.0\n")
            #f.write("#Generated by guix_module\n")
            f.write("set ModulesVersion %s\n" % new_version)

    @staticmethod
    def get_default_version(modulename):
        stdout = subprocess.check_output("module show '%s' 2>&1" % modulename, shell=True)
        version_s = stdout.split("\n")[1].split(':')[0].split("/")[-1]
        return version_s

if __name__ == '__main__':
    external_package_path = '/srv/db/guix/external'
    parser = argparse.ArgumentParser()
    parser.add_argument('-i','--install', metavar='package_name', help='package to be installed', required=True)
    parser.add_argument('--guix_package_names', nargs='+', metavar='name', help='the name of the package(s) in guix (default: the one specified with --install)')
    parser.add_argument('--version', metavar='version', help='install the module as this version (default: the one specified in Guix)')
    parser.add_argument('-t','--test_directory', metavar='path', help='run guix, but output to this directory for testing (default: unused)')
    parser.add_argument('--sw_directory', metavar='path', help='path to base directory of where to install the guix profile', default='/srv/sw')
    parser.add_argument('--module_directory', metavar='path',
                        help='path to base directory of where to install the module file', default='/srv/modulefiles')
    parser.add_argument('-e','--external', action='store_true',
                        help='use packages external to the main Guix repository available in \'%s\''\
                        % external_package_path,
                        default=False)
    parser.add_argument(
        '--guix_binary',
        metavar='path',
        help="how to run the guix executable e.g. 'guix' or '/srv/home/uqbwoodc/git/guix/pre-inst-env guix",
        default="guix")
    parser.add_argument('--debug', help='output debug information', action="store_true")
    parser.add_argument(
        '--non_default_version',
        help='Do not ensure this install becomes the default for module load',
        action='store_true')

    args = parser.parse_args()

    if args.debug:
        loglevel = logging.DEBUG
    else:
        loglevel = logging.INFO
    logging.basicConfig(level=loglevel, format='%(asctime)s %(levelname)s: %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')

    guix_package_names = [args.install]
    if args.guix_package_names:
        guix_package_names = args.guix_package_names
    guix_package_names.append('glibc-locales')
    guix_exe = args.guix_binary
    logging.info("Using guix binary: '%s'" % guix_exe)

    # get external package path together
    if args.external:
        external_repos = [f for f in os.listdir(external_package_path) if \
                          os.path.isdir(os.path.join(external_package_path, f))]
        external_prefix = 'GUIX_PACKAGE_PATH='+\
                          ':'.join(['%s/%s' % (external_package_path, d) for d in external_repos])+' '
        guix_exe = external_prefix + args.guix_binary
        logging.info("Setting guix binary program to '%s'" % guix_exe)

    # make sure that the guix package exists, and gather info on it at the same time
    # using guix package --show=guix_package_name
    guix_info = GuixInfo(guix_package_names, guix_exe)

    # Set version number if specified
    if args.version:
        logging.info("Setting version as '{}'".format(args.version))
        guix_info.version = args.version

    # create or make sure that the directory exists on the server
    # use package_name/version
    if args.test_directory:
        sw_folder = os.path.join(args.test_directory, 'sw', args.install, guix_info.version)
        modulefile_folder = os.path.join(args.test_directory, args.install)
    else:
        sw_folder = os.path.join(args.sw_directory, args.install, guix_info.version)
        modulefile_folder = os.path.join(args.module_directory, args.install)
    guix_profile_path = os.path.join(sw_folder, 'guix_package')
    module_file = os.path.join(modulefile_folder, guix_info.version)
    logging.info("Modulefile to be created at %s" % module_file)

    # ensure 'guix_profile' doesn't exist as a folder in that directory
    # ensure that the modulefile does not already exist
    if os.path.exists(sw_folder) and os.listdir(sw_folder) != []:
        raise Exception("A folder already exists at %s" % sw_folder)
    if not os.path.isdir(sw_folder):
        os.makedirs(sw_folder)
    if os.path.exists(module_file):
        raise Exception("A modulefile already exists at %s" % module_file)
    if not os.path.isdir(modulefile_folder):
        os.makedirs(modulefile_folder)

    # run guix package -i to do the actual installation to the profile
    cmd = "%s package --fallback -p '%s' -i %s" % (guix_exe, guix_profile_path, ' '.join(guix_package_names))
    logging.info("Running cmd: %s" % cmd)
    subprocess.check_call(cmd, shell=True)
    print "Do not worry about above notices that 'The following environment variable definitions may be needed'"

    # run guix package --search-paths to get the paths
    paths = SearchPaths(guix_profile_path)

    # write info and etc to the module file,
    with open(module_file,'w') as mfile:
        mfile.write("#%Module######################################################################\n")
        mfile.write("#\n")
        mfile.write("#        %s modulefile\n" % args.install)
        mfile.write("#        generated from guix package %s/%s\n" %
                    (guix_info.name, guix_info.version))
        mfile.write("#\n")
        mfile.write("proc ModulesHelp { } {\n")
        mfile.write("    puts stderr \"%s\"\n" % guix_info.synopsis)
        mfile.write("}\n")
        mfile.write("\n")
        for env_name, env_value in paths.search_paths.iteritems():
            mfile.write("prepend-path %s %s\n" % (env_name, env_value))
        # Add locale for all packages
        mfile.write("prepend-path GUIX_LOCPATH %s/lib/locale\n" % guix_profile_path)


    # Make sure that the correct version is being loaded
    if args.non_default_version:
        logging.info("Not checking this module is loaded by default")
    else:
        modulename = args.install
        moduleversion = guix_info.version
        current_version = DefaultModuleVersionFile.get_default_version(modulename)
        logging.debug("Before messing with .version files, default version is %s" % current_version)
        if current_version != moduleversion:
            logging.debug("Versions differ (found %s as default), need to specify a .version file" % current_version)
            DefaultModuleVersionFile().generate_dotversion(modulefile_folder, moduleversion)
            current_version = DefaultModuleVersionFile.get_default_version(modulename)
            if current_version != moduleversion:
                raise Exception("Unexpectedly generating a .version file did not result in the expected version being loaded")
            else:
                logging.info("After creating the .version file, the expected version (%s) now loads by default." % current_version)
        else:
            logging.debug("No .version file required")

        logging.info("Installation and modulefile creation appears to have completed without any problems.")
